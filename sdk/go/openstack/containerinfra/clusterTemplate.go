// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package containerinfra

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Manages a V1 Magnum cluster template resource within OpenStack.
// 
// ## Argument reference
// 
// The following arguments are supported:
// 
// * `region` - (Optional) The region in which to obtain the V1 Container Infra
//     client. A Container Infra client is needed to create a cluster template. If
//     omitted,the `region` argument of the provider is used. Changing this
//     creates a new cluster template.
// 
// * `name` - (Required) The name of the cluster template. Changing this updates
//     the name of the existing cluster template.
// 
// * `projectId` - (Optional) The project of the cluster template. Required if
//     admin wants to create a cluster template in another project. Changing this
//     creates a new cluster template.
// 
// * `userId` - (Optional) The user of the cluster template. Required if admin
//     wants to create a cluster template for another user. Changing this creates
//     a new cluster template.
// 
// * `apiserverPort` - (Optional) The API server port for the Container
//     Orchestration Engine for this cluster template. Changing this updates the
//     API server port of the existing cluster template.
// 
// * `coe` - (Required) The Container Orchestration Engine for this cluster
//     template. Changing this updates the engine of the existing cluster
//     template.
// 
// * `clusterDistro` - (Optional) The distro for the cluster (fedora-atomic,
//     coreos, etc.). Changing this updates the cluster distro of the existing
//     cluster template.
// 
// * `dnsNameserver` - (Optional) Address of the DNS nameserver that is used in
//     nodes of the cluster. Changing this updates the DNS nameserver of the
//     existing cluster template.
// 
// * `dockerStorageDriver` - (Optional) Docker storage driver. Changing this
//     updates the Docker storage driver of the existing cluster template.
// 
// * `dockerVolumeSize` - (Optional) The size (in GB) of the Docker volume.
//     Changing this updates the Docker volume size of the existing cluster
//     template.
// 
// * `externalNetworkId` - (Optional) The ID of the external network that will
//     be used for the cluster. Changing this updates the external network ID of
//     the existing cluster template.
// 
// * `fixedNetwork` - (Optional) The fixed network that will be attached to the
//     cluster. Changing this updates the fixed network of the existing cluster
//     template.
// 
// * `fixedSubnet` - (Optional) The fixed subnet that will be attached to the
//     cluster. Changing this updates the fixed subnet of the existing cluster
//     template.
// 
// * `flavor` - (Optional) The flavor for the nodes of the cluster. Can be set via
//     the `OS_MAGNUM_FLAVOR` environment variable. Changing this updates the
//     flavor of the existing cluster template.
// 
// * `masterFlavor` - (Optional) The flavor for the master nodes. Can be set via
//     the `OS_MAGNUM_MASTER_FLAVOR` environment variable. Changing this updates
//     the master flavor of the existing cluster template.
// 
// * `floatingIpEnabled` - (Optional) Indicates whether created cluster should
//     create floating IP for every node or not. Changing this updates the
//     floating IP enabled attribute of the existing cluster template.
// 
// * `httpProxy` - (Optional) The address of a proxy for receiving all HTTP
//     requests and relay them. Changing this updates the HTTP proxy address of
//     the existing cluster template.
// 
// * `httpsProxy` - (Optional) The address of a proxy for receiving all HTTPS
//     requests and relay them. Changing this updates the HTTPS proxy address of
//     the existing cluster template.
// 
// * `image` - (Required) The reference to an image that is used for nodes of the
//     cluster. Can be set via the `OS_MAGNUM_IMAGE` environment variable.
//     Changing this updates the image attribute of the existing cluster template.
// 
// * `insecureRegistry` - (Optional) The insecure registry URL for the cluster
//     template. Changing this updates the insecure registry attribute of the
//     existing cluster template.
// 
// * `keypairId` - (Optional) The name of the Compute service SSH keypair.
//     Changing this updates the keypair of the existing cluster template.
// 
// * `labels` - (Optional) The list of key value pairs representing additional
//     properties of the cluster template. Changing this updates the labels of the
//     existing cluster template.
// 
// * `masterLbEnabled` - (Optional) Indicates whether created cluster should
//     has a loadbalancer for master nodes or not. Changing this updates the
//     attribute of the existing cluster template.
// 
// * `networkDriver` - (Optional) The name of the driver for the container
//     network. Changing this updates the network driver of the existing cluster
//     template.
// 
// * `noProxy` - (Optional) A comma-separated list of IP addresses that shouldn't
//     be used in the cluster. Changing this updates the no proxy list of the
//     existing cluster template.
// 
// * `public` - (Optional) Indicates whether cluster template should be public.
//     Changing this updates the public attribute of the existing cluster
//     template.
// 
// * `registryEnabled` - (Optional) Indicates whether Docker registry is enabled
//     in the cluster. Changing this updates the registry enabled attribute of the
//     existing cluster template.
// 
// * `serverType` - (Optional) The server type for the cluster template. Changing
//     this updates the server type of the existing cluster template.
// 
// * `tlsDisabled` - (Optional) Indicates whether the TLS should be disabled in
//     the cluster. Changing this updates the attribute of the existing cluster.
// 
// * `volumeDriver` - (Optional) The name of the driver that is used for the
//     volumes of the cluster nodes. Changing this updates the volume driver of
//     the existing cluster template.
// 
// ## Attributes reference
// 
// The following attributes are exported:
// 
// * `region` - See Argument Reference above.
// * `name` - See Argument Reference above.
// * `projectId` - See Argument Reference above.
// * `createdAt` - The time at which cluster template was created.
// * `updatedAt` - The time at which cluster template was created.
// * `apiserverPort` - See Argument Reference above.
// * `coe` - See Argument Reference above.
// * `clusterDistro` - See Argument Reference above.
// * `dnsNameserver` - See Argument Reference above.
// * `dockerStorageDriver` - See Argument Reference above.
// * `dockerVolumeSize` - See Argument Reference above.
// * `externalNetworkId` - See Argument Reference above.
// * `fixedNetwork` - See Argument Reference above.
// * `fixedSubnet` - See Argument Reference above.
// * `flavor` - See Argument Reference above.
// * `masterFlavor` - See Argument Reference above.
// * `floatingIpEnabled` - See Argument Reference above.
// * `httpProxy` - See Argument Reference above.
// * `httpsProxy` - See Argument Reference above.
// * `image` - See Argument Reference above.
// * `insecureRegistry` - See Argument Reference above.
// * `keypairId` - See Argument Reference above.
// * `labels` - See Argument Reference above.
// * `links` - A list containing associated cluster template links.
// * `masterLbEnabled` - See Argument Reference above.
// * `networkDriver` - See Argument Reference above.
// * `noProxy` - See Argument Reference above.
// * `public` - See Argument Reference above.
// * `registryEnabled` - See Argument Reference above.
// * `serverType` - See Argument Reference above.
// * `tlsDisabled` - See Argument Reference above.
// * `volumeDriver` - See Argument Reference above.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-openstack/blob/master/website/docs/r/containerinfra_clustertemplate_v1.html.markdown.
type ClusterTemplate struct {
	s *pulumi.ResourceState
}

// NewClusterTemplate registers a new resource with the given unique name, arguments, and options.
func NewClusterTemplate(ctx *pulumi.Context,
	name string, args *ClusterTemplateArgs, opts ...pulumi.ResourceOpt) (*ClusterTemplate, error) {
	if args == nil || args.Coe == nil {
		return nil, errors.New("missing required argument 'Coe'")
	}
	if args == nil || args.Image == nil {
		return nil, errors.New("missing required argument 'Image'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["apiserverPort"] = nil
		inputs["clusterDistro"] = nil
		inputs["coe"] = nil
		inputs["dnsNameserver"] = nil
		inputs["dockerStorageDriver"] = nil
		inputs["dockerVolumeSize"] = nil
		inputs["externalNetworkId"] = nil
		inputs["fixedNetwork"] = nil
		inputs["fixedSubnet"] = nil
		inputs["flavor"] = nil
		inputs["floatingIpEnabled"] = nil
		inputs["httpProxy"] = nil
		inputs["httpsProxy"] = nil
		inputs["image"] = nil
		inputs["insecureRegistry"] = nil
		inputs["keypairId"] = nil
		inputs["labels"] = nil
		inputs["masterFlavor"] = nil
		inputs["masterLbEnabled"] = nil
		inputs["name"] = nil
		inputs["networkDriver"] = nil
		inputs["noProxy"] = nil
		inputs["public"] = nil
		inputs["region"] = nil
		inputs["registryEnabled"] = nil
		inputs["serverType"] = nil
		inputs["tlsDisabled"] = nil
		inputs["volumeDriver"] = nil
	} else {
		inputs["apiserverPort"] = args.ApiserverPort
		inputs["clusterDistro"] = args.ClusterDistro
		inputs["coe"] = args.Coe
		inputs["dnsNameserver"] = args.DnsNameserver
		inputs["dockerStorageDriver"] = args.DockerStorageDriver
		inputs["dockerVolumeSize"] = args.DockerVolumeSize
		inputs["externalNetworkId"] = args.ExternalNetworkId
		inputs["fixedNetwork"] = args.FixedNetwork
		inputs["fixedSubnet"] = args.FixedSubnet
		inputs["flavor"] = args.Flavor
		inputs["floatingIpEnabled"] = args.FloatingIpEnabled
		inputs["httpProxy"] = args.HttpProxy
		inputs["httpsProxy"] = args.HttpsProxy
		inputs["image"] = args.Image
		inputs["insecureRegistry"] = args.InsecureRegistry
		inputs["keypairId"] = args.KeypairId
		inputs["labels"] = args.Labels
		inputs["masterFlavor"] = args.MasterFlavor
		inputs["masterLbEnabled"] = args.MasterLbEnabled
		inputs["name"] = args.Name
		inputs["networkDriver"] = args.NetworkDriver
		inputs["noProxy"] = args.NoProxy
		inputs["public"] = args.Public
		inputs["region"] = args.Region
		inputs["registryEnabled"] = args.RegistryEnabled
		inputs["serverType"] = args.ServerType
		inputs["tlsDisabled"] = args.TlsDisabled
		inputs["volumeDriver"] = args.VolumeDriver
	}
	inputs["createdAt"] = nil
	inputs["projectId"] = nil
	inputs["updatedAt"] = nil
	inputs["userId"] = nil
	s, err := ctx.RegisterResource("openstack:containerinfra/clusterTemplate:ClusterTemplate", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &ClusterTemplate{s: s}, nil
}

// GetClusterTemplate gets an existing ClusterTemplate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClusterTemplate(ctx *pulumi.Context,
	name string, id pulumi.ID, state *ClusterTemplateState, opts ...pulumi.ResourceOpt) (*ClusterTemplate, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["apiserverPort"] = state.ApiserverPort
		inputs["clusterDistro"] = state.ClusterDistro
		inputs["coe"] = state.Coe
		inputs["createdAt"] = state.CreatedAt
		inputs["dnsNameserver"] = state.DnsNameserver
		inputs["dockerStorageDriver"] = state.DockerStorageDriver
		inputs["dockerVolumeSize"] = state.DockerVolumeSize
		inputs["externalNetworkId"] = state.ExternalNetworkId
		inputs["fixedNetwork"] = state.FixedNetwork
		inputs["fixedSubnet"] = state.FixedSubnet
		inputs["flavor"] = state.Flavor
		inputs["floatingIpEnabled"] = state.FloatingIpEnabled
		inputs["httpProxy"] = state.HttpProxy
		inputs["httpsProxy"] = state.HttpsProxy
		inputs["image"] = state.Image
		inputs["insecureRegistry"] = state.InsecureRegistry
		inputs["keypairId"] = state.KeypairId
		inputs["labels"] = state.Labels
		inputs["masterFlavor"] = state.MasterFlavor
		inputs["masterLbEnabled"] = state.MasterLbEnabled
		inputs["name"] = state.Name
		inputs["networkDriver"] = state.NetworkDriver
		inputs["noProxy"] = state.NoProxy
		inputs["projectId"] = state.ProjectId
		inputs["public"] = state.Public
		inputs["region"] = state.Region
		inputs["registryEnabled"] = state.RegistryEnabled
		inputs["serverType"] = state.ServerType
		inputs["tlsDisabled"] = state.TlsDisabled
		inputs["updatedAt"] = state.UpdatedAt
		inputs["userId"] = state.UserId
		inputs["volumeDriver"] = state.VolumeDriver
	}
	s, err := ctx.ReadResource("openstack:containerinfra/clusterTemplate:ClusterTemplate", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &ClusterTemplate{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *ClusterTemplate) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *ClusterTemplate) ID() *pulumi.IDOutput {
	return r.s.ID()
}

func (r *ClusterTemplate) ApiserverPort() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["apiserverPort"])
}

func (r *ClusterTemplate) ClusterDistro() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["clusterDistro"])
}

func (r *ClusterTemplate) Coe() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["coe"])
}

func (r *ClusterTemplate) CreatedAt() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["createdAt"])
}

func (r *ClusterTemplate) DnsNameserver() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["dnsNameserver"])
}

func (r *ClusterTemplate) DockerStorageDriver() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["dockerStorageDriver"])
}

func (r *ClusterTemplate) DockerVolumeSize() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["dockerVolumeSize"])
}

func (r *ClusterTemplate) ExternalNetworkId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["externalNetworkId"])
}

func (r *ClusterTemplate) FixedNetwork() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["fixedNetwork"])
}

func (r *ClusterTemplate) FixedSubnet() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["fixedSubnet"])
}

func (r *ClusterTemplate) Flavor() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["flavor"])
}

func (r *ClusterTemplate) FloatingIpEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["floatingIpEnabled"])
}

func (r *ClusterTemplate) HttpProxy() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["httpProxy"])
}

func (r *ClusterTemplate) HttpsProxy() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["httpsProxy"])
}

func (r *ClusterTemplate) Image() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["image"])
}

func (r *ClusterTemplate) InsecureRegistry() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["insecureRegistry"])
}

func (r *ClusterTemplate) KeypairId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["keypairId"])
}

func (r *ClusterTemplate) Labels() *pulumi.MapOutput {
	return (*pulumi.MapOutput)(r.s.State["labels"])
}

func (r *ClusterTemplate) MasterFlavor() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["masterFlavor"])
}

func (r *ClusterTemplate) MasterLbEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["masterLbEnabled"])
}

func (r *ClusterTemplate) Name() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["name"])
}

func (r *ClusterTemplate) NetworkDriver() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["networkDriver"])
}

func (r *ClusterTemplate) NoProxy() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["noProxy"])
}

func (r *ClusterTemplate) ProjectId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["projectId"])
}

func (r *ClusterTemplate) Public() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["public"])
}

func (r *ClusterTemplate) Region() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["region"])
}

func (r *ClusterTemplate) RegistryEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["registryEnabled"])
}

func (r *ClusterTemplate) ServerType() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["serverType"])
}

func (r *ClusterTemplate) TlsDisabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["tlsDisabled"])
}

func (r *ClusterTemplate) UpdatedAt() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["updatedAt"])
}

func (r *ClusterTemplate) UserId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["userId"])
}

func (r *ClusterTemplate) VolumeDriver() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["volumeDriver"])
}

// Input properties used for looking up and filtering ClusterTemplate resources.
type ClusterTemplateState struct {
	ApiserverPort interface{}
	ClusterDistro interface{}
	Coe interface{}
	CreatedAt interface{}
	DnsNameserver interface{}
	DockerStorageDriver interface{}
	DockerVolumeSize interface{}
	ExternalNetworkId interface{}
	FixedNetwork interface{}
	FixedSubnet interface{}
	Flavor interface{}
	FloatingIpEnabled interface{}
	HttpProxy interface{}
	HttpsProxy interface{}
	Image interface{}
	InsecureRegistry interface{}
	KeypairId interface{}
	Labels interface{}
	MasterFlavor interface{}
	MasterLbEnabled interface{}
	Name interface{}
	NetworkDriver interface{}
	NoProxy interface{}
	ProjectId interface{}
	Public interface{}
	Region interface{}
	RegistryEnabled interface{}
	ServerType interface{}
	TlsDisabled interface{}
	UpdatedAt interface{}
	UserId interface{}
	VolumeDriver interface{}
}

// The set of arguments for constructing a ClusterTemplate resource.
type ClusterTemplateArgs struct {
	ApiserverPort interface{}
	ClusterDistro interface{}
	Coe interface{}
	DnsNameserver interface{}
	DockerStorageDriver interface{}
	DockerVolumeSize interface{}
	ExternalNetworkId interface{}
	FixedNetwork interface{}
	FixedSubnet interface{}
	Flavor interface{}
	FloatingIpEnabled interface{}
	HttpProxy interface{}
	HttpsProxy interface{}
	Image interface{}
	InsecureRegistry interface{}
	KeypairId interface{}
	Labels interface{}
	MasterFlavor interface{}
	MasterLbEnabled interface{}
	Name interface{}
	NetworkDriver interface{}
	NoProxy interface{}
	Public interface{}
	Region interface{}
	RegistryEnabled interface{}
	ServerType interface{}
	TlsDisabled interface{}
	VolumeDriver interface{}
}
